# 为什么处理排序数组比处理不排序的要快 #
Here is a piece of C++ code that shows some very peculiar performance. For some strange reason, sorting the data miraculously speeds up the code by almost 6x:
下面是一段C++代码显示了一些非常奇特的性能。由于一些奇怪的原因，对数据排序奇迹般的提升了代码的执行速度差不多6倍：
```C
#include <algorithm>
#include <ctime>
#include <iostream>

int main()
{
    //  生成数据
    const unsigned arraySize = 32768;
    int data[arraySize];

    for (unsigned c = 0; c < arraySize; ++c)
        data[c] = std::rand() % 256;

    // ！！！调用以下代码，下面的循环跑的更快
    std::sort(data, data + arraySize);

    // 测试 
    clock_t start = clock();
    long long sum = 0;

    for (unsigned i = 0; i < 100000; ++i)
    {
        //  主循环
        for (unsigned c = 0; c < arraySize; ++c)
        {
            if (data[c] >= 128)
                sum += data[c];
        }
    }

    double elapsedTime = static_cast<double>(clock() - start) / CLOCKS_PER_SEC;

    std::cout << elapsedTime << std::endl;
    std::cout << "sum = " << sum << std::endl;
}
```
- Without std::sort(data, data + arraySize);, the code runs in 11.54 seconds.
- 没有使用代码 std::sort(data, data + arraySize);，代码执行时间 11.54 秒。
- With the sorted data, the code runs in 1.93 seconds.
- 使用数据排序，代码执行时间 1.93 秒。

Initially I thought this might be just a language or compiler anomaly. So I tried it in Java:
起初我以为可能是语言或者编译器的问题。所以我在 Java 上尝试：
```JAVA
import java.util.Arrays;
import java.util.Random;

public class Main
{
    public static void main(String[] args)
    {
        // 生成数据
        int arraySize = 32768;
        int data[] = new int[arraySize];

        Random rnd = new Random(0);
        for (int c = 0; c < arraySize; ++c)
            data[c] = rnd.nextInt() % 256;

        // ！！！调用以下代码，下面的循环跑的更快
        Arrays.sort(data);

        // 测试 
        long start = System.nanoTime();
        long sum = 0;

        for (int i = 0; i < 100000; ++i)
        {
            // 主循环 
            for (int c = 0; c < arraySize; ++c)
            {
                if (data[c] >= 128)
                    sum += data[c];
            }
        }

        System.out.println((System.nanoTime() - start) / 1000000000.0);
        System.out.println("sum = " + sum);
    }
}
```
with a similar but less extreme result.
类似但不那么极端的结果。

-----------
My first thought was that sorting brings the data into cache, but my next thought was how silly that is because the array was just generated.
我的第一个想法是数据排序后被放入缓存中，但是下一秒我就否定了，这样做太愚蠢了因为数组才刚刚生成。
What is going on? Why is a sorted array faster than an unsorted array? The code is summing up some independent terms, the order should not matter.
到底是怎么回事？为什么一个有序数组比无序数组更快？这个代码将无关项求和，排序不应该有影响。

## 解答 ## 
You are a victim of [branch prediction](https://en.wikipedia.org/wiki/Branch_predictor) fail.
你是 《[分支预测器失败](https://en.wikipedia.org/wiki/Branch_predictor)》 的受害者
**What is Branch Prediction?**
Consider a railroad junction:
考虑一个铁路枢纽：

Image by Mecanismo, via Wikimedia Commons. Used under the CC-By-SA 3.0 license.
图片由Mecanismo拍摄，从维基共享资源获得。根据 CC-BY-SA 3.0 许可使用。
Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication.
现在为了论证，假设这是在 19 世纪 -- 长途或无线电通信产生之前。
You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want. And then you set the switch appropriately.
你是一个铁路枢纽的操作员并且你听到火车即将到达。你不知道火车应该往哪条路行驶。你让火车停下并询问驾驶员他们想要哪个方向。接着你适当的设置开关。
Trains are heavy and have a lot of inertia. So they take forever to start up and slow down.
**火车很重，有很大的惯性。因此它们永远处于启动和减速过程中**。
Is there a better way? You guess which direction the train will go!
- If you guessed right, it continues on.
- If you guessed wrong, the captain will stop, back up, and yell at you to flip the switch. Then it can restart down the other path.
有没有更好的办法？你猜列车将往哪个方向走！
- 如果猜对了，它将继续行驶
- 如果猜错了，火车司机会停下火车，加固刹车，并且对你大喊大叫让你切换开关。然后，它重新启动，朝着另一条路行驶。

If you guess right every time, the train will never have to stop.
**如果你每次都猜对了**，该火车将永远不会停下来
If you guess wrong too often, the train will spend a lot of time stopping, backing up, and restarting.
**如果你经常猜错**，该火车将花费许多的时间停下来，加固刹车，和重新启动。

----------

Consider an if-statement: At the processor level, it is a branch instruction:
**考虑一个 if 语句**：在处理器级别，这是一个分支指令：
图片


You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path.
你是一个处理器并看到一个分支。你根本不知道它会运行哪一个分支。你是做什么？你停止执行，等待前面的指令完成。然后你继续沿着正确的路径前进。
Modern processors are complicated and have long pipelines. So they take forever to "warm up" and "slow down".
**现代处理器复杂并拥有长管道。因此它们永远处于“热身”和“减速”状态**
Is there a better way? You guess which direction the branch will go!
- If you guessed right, you continue executing.
- If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.

有没有更好的办法？你猜测这个分支会往哪个方向走。
- 如果猜测正确，你继续往下执行
- 如果猜测错误，你反需要刷新管道，回滚到该分支。然后，你重新开始，沿着另外一条路径运行。

If you guess right every time, the execution will never have to stop.
**如果你每次都猜测正解**，该执行将永远不会停止。
If you guess wrong too often, you spend a lot of time stalling, rolling back, and restarting.
**如果你经常猜测错误**，你花费很多时间停止，回滚，和重新启动。

----------

This is branch prediction. I admit it's not the best analogy since the train could just signal the direction with a flag. But in computers, the processor doesn't know which direction a branch will go until the last moment.
这就是分支预测。我承认这不是最好的比喻因为火车仅能通过旗帜来示意方向。但是在计算机中，处理器不会知道一个会支会往哪个方向直到最后一刻为止。
So how would you strategically guess to minimize the number of times that the train must back up and go down the other path? You look at the past history! If the train goes left 99% of the time, then you guess left. If it alternates, then you alternate your guesses. If it goes one way every 3 times, you guess the same...
所以你将如何战略性猜测使得火车加固刹车并且往另外一条路线走的次数最少。你查看过去的记录！如果该火车99%的时间都是往左走，那么你猜测往左。如果往左往右交替出现，那么你交替你的猜测。如果它每三次向一条路行驶，你以同样的方式猜测……
In other words, you try to identify a pattern and follow it. This is more or less how branch predictors work.
**就是说，你尝试确定一种模式然后遵循它**。这大致就是分支预测如何工作的原理。
Most applications have well-behaved branches. So modern branch predictors will typically achieve >90% hit rates. But when faced with unpredictable branches with no recognizable patterns, branch predictors are virtually useless.
大多数应用都有规矩的分支。所以，现代的分支预测通常达到 >90％ 的命中率。但是，当面对没有可识别模式，不可预知的分支，分支预测实质上是无用的。
Further reading: ["Branch predictor" article on Wikipedia.](http://en.wikipedia.org/wiki/Branch_predictor)
深入阅读：维基百科上的文章《[分支预测](http://en.wikipedia.org/wiki/Branch_predictor)》

---------

### As hinted from above, the culprit is this if-statement: ###
### 
```C
if (data[c] >= 128)
    sum += data[c];
```

Notice that the data is evenly distributed between 0 and 255. When the data is sorted, roughly the first half of the iterations will not enter the if-statement. After that, they will all enter the if-statement.

This is very friendly to the branch predictor since the branch consecutively goes the same direction many times. Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.

**Quick visualization**:
```C
T = branch taken
N = branch not taken

data[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...
branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...

       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)
```
However, when the data is completely random, the branch predictor is rendered useless because it can't predict random data. Thus there will probably be around 50% misprediction. (no better than random guessing)

data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, 133, ...
branch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T,   N  ...

       = TTNTTTTNTNNTTTN ...   (completely random - hard to predict)







