# 为什么处理排序数组比处理不排序的要快 #
Here is a piece of C++ code that shows some very peculiar performance. For some strange reason, sorting the data miraculously speeds up the code by almost 6x:
下面是一段C++代码显示了一些非常奇特的性能。由于一些奇怪的原因，对数据排序奇迹般的提升了代码的执行速度差不多6倍：
```C
#include <algorithm>
#include <ctime>
#include <iostream>

int main()
{
    //  生成数据
    const unsigned arraySize = 32768;
    int data[arraySize];

    for (unsigned c = 0; c < arraySize; ++c)
        data[c] = std::rand() % 256;

    // ！！！调用以下代码，下面的循环跑的更快
    std::sort(data, data + arraySize);

    // 测试 
    clock_t start = clock();
    long long sum = 0;

    for (unsigned i = 0; i < 100000; ++i)
    {
        //  主循环
        for (unsigned c = 0; c < arraySize; ++c)
        {
            if (data[c] >= 128)
                sum += data[c];
        }
    }

    double elapsedTime = static_cast<double>(clock() - start) / CLOCKS_PER_SEC;

    std::cout << elapsedTime << std::endl;
    std::cout << "sum = " << sum << std::endl;
}
```
- Without std::sort(data, data + arraySize);, the code runs in 11.54 seconds.
- 没有使用代码 std::sort(data, data + arraySize);，代码执行时间 11.54 秒。
- With the sorted data, the code runs in 1.93 seconds.
- 使用数据排序，代码执行时间 1.93 秒。

Initially I thought this might be just a language or compiler anomaly. So I tried it in Java:
起初我以为可能是语言或者编译器的问题。所以我在 Java 上尝试：
```JAVA
import java.util.Arrays;
import java.util.Random;

public class Main
{
    public static void main(String[] args)
    {
        // 生成数据
        int arraySize = 32768;
        int data[] = new int[arraySize];

        Random rnd = new Random(0);
        for (int c = 0; c < arraySize; ++c)
            data[c] = rnd.nextInt() % 256;

        // ！！！调用以下代码，下面的循环跑的更快
        Arrays.sort(data);

        // 测试 
        long start = System.nanoTime();
        long sum = 0;

        for (int i = 0; i < 100000; ++i)
        {
            // 主循环 
            for (int c = 0; c < arraySize; ++c)
            {
                if (data[c] >= 128)
                    sum += data[c];
            }
        }

        System.out.println((System.nanoTime() - start) / 1000000000.0);
        System.out.println("sum = " + sum);
    }
}
```
with a similar but less extreme result.
类似但不那么极端的结果。

-----------
My first thought was that sorting brings the data into cache, but my next thought was how silly that is because the array was just generated.
我的第一个想法是数据排序后被放入缓存中，但是下一秒我就否定了，这样做太愚蠢了因为数组才刚刚生成。
What is going on? Why is a sorted array faster than an unsorted array? The code is summing up some independent terms, the order should not matter.
到底是怎么回事？为什么一个有序数组比无序数组更快？这个代码将无关项求和，排序不应该有影响。

## 解答 ## 
You are a victim of [branch prediction](https://en.wikipedia.org/wiki/Branch_predictor) fail.
你是 《[分支预测器失败](https://en.wikipedia.org/wiki/Branch_predictor)》 的受害者
**What is Branch Prediction?**
Consider a railroad junction:
考虑一个铁路枢纽：

Image by Mecanismo, via Wikimedia Commons. Used under the CC-By-SA 3.0 license.
图片由Mecanismo拍摄，从维基共享资源获得。根据 CC-BY-SA 3.0 许可使用。
Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication.
现在为了论证，假设这是在 19 世纪 -- 长途或无线电通信产生之前。
You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want. And then you set the switch appropriately.
你是一个铁路枢纽的操作员并且你听到火车即将到达。你不知道火车应该往哪条路行驶。你让火车停下并询问驾驶员他们想要哪个方向。接着你适当的设置开关。
Trains are heavy and have a lot of inertia. So they take forever to start up and slow down.
**火车很重，有很大的惯性。因此它们永远处于启动和减速过程中**。
Is there a better way? You guess which direction the train will go!
- If you guessed right, it continues on.
- If you guessed wrong, the captain will stop, back up, and yell at you to flip the switch. Then it can restart down the other path.
有没有更好的办法？你猜列车将往哪个方向走！
- 如果猜对了，它将继续行驶
- 如果猜错了，火车司机会停下火车，加固刹车，并且对你大喊大叫让你切换开关。然后，它重新启动，朝着另一条路行驶。

If you guess right every time, the train will never have to stop.
**如果你每次都猜对了**，该火车将永远不会停下来
If you guess wrong too often, the train will spend a lot of time stopping, backing up, and restarting.
**如果你经常猜错**，该火车将花费许多的时间停下来，加固刹车，和重新启动。

----------

Consider an if-statement: At the processor level, it is a branch instruction:
**考虑一个 if 语句**：在处理器级别，这是一个分支指令：
图片


You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path.
你是一个处理器并看到一个分支。你根本不知道它会运行哪一个分支。你是做什么？你停止执行，等待前面的指令完成。然后你继续沿着正确的路径前进。
Modern processors are complicated and have long pipelines. So they take forever to "warm up" and "slow down".
**现代处理器复杂并拥有长管道。因此它们永远处于“热身”和“减速”状态**
Is there a better way? You guess which direction the branch will go!
- If you guessed right, you continue executing.
- If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.

有没有更好的办法？你猜测这个分支会往哪个方向走。
- 如果猜测正确，你继续往下执行
- 如果猜测错误，你反需要刷新管道，回滚到该分支。然后，你重新开始，沿着另外一条路径运行。

If you guess right every time, the execution will never have to stop.
**如果你每次都猜测正解**，该执行将永远不会停止。
If you guess wrong too often, you spend a lot of time stalling, rolling back, and restarting.
**如果你经常猜测错误**，你花费很多时间停止，回滚，和重新启动。

----------









